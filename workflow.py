import shlex
from pathlib import Path
from types import SimpleNamespace

import aiofiles
from virtool_workflow import step
from virtool_workflow.analysis.indexes import Index
from virtool_workflow.analysis.reads import Reads
from virtool_workflow.analysis.subtractions import Subtraction
from virtool_workflow.execution.run_subprocess import RunSubprocess


@step
async def map_default_isolates(
        pathoscope,
        intermediate: SimpleNamespace,
        reads: Reads,
        index: Index,
        proc: int,
        p_score_cutoff: float,
        run_subprocess: RunSubprocess,
        logger,
):
    """
    Map reads to the main OTU reference.

    This will be used to identify canididate OTUs.
    """

    async def stdout_handler(line: str):
        logger.debug(line)

        if line[0] == "#" or line[0] == "@":
            return

        fields = line.split("\t")

        # Bitwise FLAG - 0x4: segment unmapped
        if int(fields[1]) & 0x4 == 4:
            return

        ref_id = fields[2]

        if ref_id == "*":
            return

        # Skip if the p_score does not meet the minimum cutoff.
        if pathoscope.find_sam_align_score(fields) < p_score_cutoff:
            return

        intermediate.to_otus.add(ref_id)

    await run_subprocess(
        [
            "bowtie2",
            "-p", str(proc),
            "--no-unal",
            "--local",
            "--score-min", "L,20,1.0",
            "-N", "0",
            "-L", "15",
            "-x", str(index.bowtie_path),
            "-U", f"{reads.left},{reads.right}",
        ],
        stdout_handler=stdout_handler
    )


@step
async def write_isolate_fasta(
        intermediate: SimpleNamespace,
        index: Index,
        proc: int,
        isolate_fasta_path: Path,
):
    intermediate.lengths = await index.write_isolate_fasta(
        [index.get_otu_id_by_sequence_id(id_) for id_ in intermediate.to_otus],
        isolate_fasta_path,
        proc
    )

    return "Produced isolate fasta file."


@step
async def build_isolate_index(
        isolate_fasta_path: Path,
        isolate_index_path: Path,
        run_subprocess: RunSubprocess,
        proc: int,
):
    """
    Build an index using the fasta file generated by :func:`.write_isolate_fasta`.
    """
    await run_subprocess(
        [
            "bowtie2-build",
            "--threads", str(proc),
            isolate_fasta_path,
            isolate_index_path
        ],
    )

    return "Built isolate index."


@step
async def map_isolates(
        pathoscope,
        intermediate,
        reads: Reads,
        isolate_fastq_path: Path,
        isolate_index_path: Path,
        isolate_vta_path: Path,
        run_subprocess: RunSubprocess,
        proc: int,
        p_score_cutoff: float
):
    """Map the sample reads to the newly built index."""
    async with aiofiles.open(isolate_vta_path, "w") as f:
        async def stdout_handler(line):
            line = line.decode()

            if line[0] == "@" or line == "#":
                return

            fields = line.split("\t")

            # Bitwise FLAG - 0x4 : segment unmapped
            if int(fields[1]) & 0x4 == 4:
                return

            ref_id = fields[2]

            if ref_id == "*":
                return

            p_score = pathoscope.find_sam_align_score(fields)

            # Skip if the p_score does not meet the minimum cutoff.
            if p_score < p_score_cutoff:
                return

            await f.write(",".join([
                fields[0],  # read_id
                ref_id,
                fields[3],  # pos
                str(len(fields[9])),  # length
                str(p_score)
            ]) + "\n")

        command = [
            "bowtie2",
            "-p", str(proc),
            "--no-unal",
            "--local",
            "--score-min", "L,20,1.0",
            "-N", "0",
            "-L", "15",
            "-k", "100",
            "--al", str(isolate_fastq_path),
            "-x", str(isolate_index_path),
            "-U", f"{reads.left},{reads.right}"
        ]

        await run_subprocess(command, stdout_handler=stdout_handler)

    return "Mapped sample reads to isolate index."


@step
async def map_subtractions(
        pathoscope,
        intermediate: SimpleNamespace,
        subtraction: Subtraction,
        run_subprocess: RunSubprocess,
        proc: int,
):
    """
    Map the reads to the subtraction host for the sample.
    """
    to_subtraction = {}

    async def stdout_handler(line):
        line = line.decode()

        if line[0] == "@" or line == "#":
            return

        fields = line.split("\t")

        # Bitwise FLAG - 0x4 : segment unmapped
        if int(fields[1]) & 0x4 == 4:
            return

        # No ref_id assigned.
        if fields[2] == "*":
            return

        to_subtraction[fields[0]] = pathoscope.find_sam_align_score(fields)

    command = [
        "bowtie2",
        "--local",
        "-N", "0",
        "-p", str(proc),
        "-x", shlex.quote(str(subtraction.path)),
        "-U", str(intermediate.isolate_mapped_fastq_path)
    ]

    await run_subprocess(command, stdout_handler=stdout_handler)

    intermediate.to_subtraction = to_subtraction

    return "Mapped reads to the subtraction host."


@step
async def subtract_mapping(
        pathoscope,
        intermediate: SimpleNamespace,
        results: dict,
        run_in_executor,
        isolate_path: Path,
):
    output_path = isolate_path / "subtracted.vta"

    subtracted_count = await pathoscope.subtract(
        intermediate.isolate_vta_path,
        output_path,
        intermediate.to_subtraction
    )

    await run_in_executor(
        pathoscope.replace_after_subtraction,
        output_path,
        intermediate.isolate_vta_path
    )

    results["subtracted_count"] = subtracted_count

    return "Performed subtraction on subtraction mapped reads."


@step
async def reassignment(
        pathoscope,
        intermediate,
        results,
        run_in_executor,
        isolate_path: Path,
        index: Index,
        p_score_cutoff: float,
):
    """
    Run the Pathoscope reassignment algorithm.

    Tab-separated output is written to `pathoscope.tsv`.

    The results are also parsed and saved to `intermediate.coverage`.
    """
    reassigned_path = isolate_path / "reassigned.vta"
    (
        best_hit_initial_reads,
        best_hit_initial,
        level_1_initial,
        level_2_initial,
        best_hit_final_reads,
        best_hit_final,
        level_1_final,
        level_2_final,
        init_pi,
        pi,
        refs,
        reads
    ) = await run_in_executor(
        pathoscope.run,
        intermediate.isolate_vta_path,
        reassigned_path,
        p_score_cutoff,
    )

    read_count = len(reads)

    report_path = isolate_path / "report.tsv"
    report = await run_in_executor(
        pathoscope.write_report,
        report_path,
        pi,
        refs,
        read_count,
        init_pi,
        best_hit_initial,
        best_hit_initial_reads,
        best_hit_final,
        best_hit_final_reads,
        level_1_initial,
        level_2_initial,
        level_1_final,
        level_2_final
    )

    intermediate.coverage = await run_in_executor(
        pathoscope.calculate_coverage,
        reassigned_path,
        intermediate.lengths
    )

    hits = list()

    for sequence_id, hit in report.items():
        otu_id = index.get_otu_id_by_sequence_id(sequence_id)

        hit["id"] = sequence_id

        # Attach "otu" (id, version) to the hit.
        hit["otu"] = {
            "id": otu_id,
            "version": index.manifest[otu_id]
        }

        # Get the coverage for the sequence.
        hit_coverage = intermediate.coverage[sequence_id]

        hit["align"] = hit_coverage

        # Calculate coverage and attach to hit.
        hit["coverage"] = round(
            1 - hit_coverage.count(0) / len(hit_coverage), 3)

        # Calculate depth and attach to hit.
        hit["depth"] = round(sum(hit_coverage) / len(hit_coverage))

        hits.append(hit)

    results.update({
        "read_count": read_count,
        "hits": hits
    })

    intermediate.reassigned_path = reassigned_path
    intermediate.report_path = report_path

    return "Pathoscope run finished."
